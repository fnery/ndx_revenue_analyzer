"""
ndx_revenue_analyzer.py
-----------------------

This script calculates the price to sales ratio (P/S) for $NDX based on
revenues generated by Indexed Finance indices (through exit fees).

IMPORTANT: To use this script, specify your etherscan API key (modify the
ETHERSCAN_API_KEY string variable accordingly)

Example
-------
Calculate P/S for the last 7 _full_ days (as of June 16th):

    $ python3 ndx_revenue_analyzer.py "2021-6-9" "2021-6-15"
    NDX P/S ratio (based on 7 avg revenue, annualized) = 109.7

Notes
-----
    The dates passed to the script as arguments are _inclusive_ (see example)
    For example, to calculate P/S for the last 7 _full_ days (as of June 16th):

    By default, this script will also saves a "png" plot with cumulative
    revenues during the specified date interval, broken down by index.
    This can be switched off by changing PLOT_REVENUE_BY_INDEX to False

"""
import sys
import requests
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
from datetime import datetime

# USER SETTINGS ---------------------------------------------------------------
ETHERSCAN_API_KEY = ""
PLOT_REVENUE_BY_INDEX = True
# USER SETTINGS ---------------------------------------------------------------

# Other constants
INDEXED_TREASURY_ADDRESS = "0x78a3eF33cF033381FEB43ba4212f2Af5A5A0a2EA"
INDEXED_TOKEN_ADDRESSES = {
    "DEFI5": "0xfa6de2697d59e88ed7fc4dfe5a33dac43565ea41",
    "CC10": "0x17ac188e09a7890a1844e5e65471fe8b0ccfadf3",
    "ORCL5": "0xd6cb2adf47655b1babddc214d79257348cbc39a7",
    "DEGEN": "0x126c121f99e1e211df2e5f8de2d96fa36647c855",
    "NFTP": "0x68bb81b3f67f7aab5fd1390ecb0b8e1a806f2465",
    "FFF": "0xabafa52d3d5a2c18a4c1ae24480d22b831fc0413"
}
INDEXED_TOKEN_COINGECKO_IDS = {
    "DEFI5": "defi-top-5-tokens-index",
    "CC10": "cryptocurrency-top-10-tokens-index",
    "ORCL5": "oracle-top-5",
    "DEGEN": "degen-index",
    "NFTP": "nft-platform-index",
    "FFF": "future-of-finance-fund"
}
NDX_COINGECKO_ID = "indexed-finance"
DAYS_IN_ONE_YEAR = 365.25
ETH_TO_WEI = 10**18


def price_to_sales(revenue, days, market_cap, price):
    """Price to sales calculator

    Parameters
    ----------
    revenue : float
        revenue
    days: int
        number of days during which revenue accumulated
    market_cap : float
        market capitalization
    price: float
        price per share

    Returns
    -------
    float
        price to sales ratio

    """
    avg_daily_revenue = revenue/days
    shares_outstanding = market_cap/price
    annualized_revenue = avg_daily_revenue*DAYS_IN_ONE_YEAR
    sales_per_share = annualized_revenue/shares_outstanding
    return price/sales_per_share


def query_to_json(query):
    """Query with requests and return response as json

    Parameters
    ----------
    query : string
        query

    Returns
    -------
    json
        response

    """
    return requests.get(query).json()


if __name__ == '__main__':
    # APIs queries
    # 1) ERC20 "transactions" from indexed token addresses into indexed treasury
    # 2) Current "prices" of the indexed tokens
    # 3) Stats about $NDX (indexed governance token) for price-to-sales calculation
    transactions = f"https://api.etherscan.io/api?module=account&action=tokentx&address={INDEXED_TREASURY_ADDRESS}&startblock=0&endblock=999999999&sort=asc&apikey={ETHERSCAN_API_KEY}"
    prices = f"https://api.coingecko.com/api/v3/simple/price?vs_currencies=usd&ids={','.join(list(INDEXED_TOKEN_COINGECKO_IDS.values()))}"
    ndx = f"https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids={NDX_COINGECKO_ID}"
    transactions = query_to_json(transactions)["result"]
    prices = query_to_json(prices)
    ndx = query_to_json(ndx)

    # Very basic input checks
    args = sys.argv[1:]
    assert len(args) == 2
    date_bounds = [datetime.strptime(x, '%Y-%m-%d').date() for x in args]
    assert date_bounds[1] > date_bounds[0]

    # From here work with transactions as a dataframe df
    df = pd.DataFrame(transactions)
    df['dateTime'] = df['timeStamp'].apply(lambda x: pd.to_datetime(x, unit='s'))
    df['dateTime'] = df['dateTime'].dt.date

    # Only want transactions between desired dates
    # date_bounds = [START_DATE, END_DATE]
    # date_bounds = [to_datetime(x) for x in date_bounds]
    after = df["dateTime"] >= date_bounds[0]
    before = df["dateTime"] <= date_bounds[1]
    between = after & before
    df = df.loc[between]

    if PLOT_REVENUE_BY_INDEX:
        fig, ax = plt.subplots()

    revenue = 0
    for (token, id) in zip(INDEXED_TOKEN_ADDRESSES, INDEXED_TOKEN_COINGECKO_IDS):

        # filter by current token and get rid of unnecessary columns
        address = INDEXED_TOKEN_ADDRESSES[token]
        tmp = df[df['from'].str.match(address)]
        tmp = tmp[['dateTime', 'value']]

        # convert to ETH
        tmp['value'] = (tmp['value'].astype(float))/ETH_TO_WEI

        # calculate cumulative sum of revenues and convert to USD
        tmp = tmp.groupby(tmp.dateTime)['value'].sum().cumsum()
        tmp = tmp*prices[INDEXED_TOKEN_COINGECKO_IDS[id]]["usd"]

        if PLOT_REVENUE_BY_INDEX:
            tmp.plot(ax=ax)

        # update total revenue with revenue from current token
        revenue = float(revenue + tmp[-1])

    if PLOT_REVENUE_BY_INDEX:
        plt.title(f"Cumulative exit fee revenue from Indexed Finance indices\n(total=${revenue:,.0f})")
        ax.legend(INDEXED_TOKEN_ADDRESSES.keys())
        tick = mtick.StrMethodFormatter('${x:,.0f}')
        ax.yaxis.set_major_formatter(tick)
        fig.autofmt_xdate()
        ax.set_xlabel('')
        fig.tight_layout()

    # Calculate price-to-sales
    nDays = (date_bounds[1] - date_bounds[0]).days + 1
    current_price = ndx[0]["current_price"]
    market_cap = float(ndx[0]["market_cap"])
    ps = price_to_sales(revenue, nDays, market_cap, current_price)

    s = f"NDX P/S ratio (based on {nDays}-day avg revenue, annualized) = {ps:.2f}"
    print(s)

    if PLOT_REVENUE_BY_INDEX:
        plt.savefig(f"revenue_per_index_{args[0]}_to_{args[1]}.png")
